/**
 * @fileOverview Core zipper data structure and generic operations.
 */
package (
// State
    path
    lefts
    rights

// Node Queries
    children
    parent

// Node Predicates
    hasChildren
    hasParent
    isRoot
    isChild
    isLeaf
    isFirst
    isLast

// Basic Movement
    up
    down
    left
    right

// Compound Movement
    root
    leftmost
    rightmost
    leftLeaf
    rightLeaf
    
    nextUpDfs
    nextDfs
    prevDfs
    
// Editing
    extract
    replace
    modify
    remove
    setLefts
    modifyLefts
    setRights
    modifyRights
    insertLeft
    insertRight
    insertChild
    appendChild

// Zipper Creation
    zipper)
with
    import 'nu-stream::stream' {
        append
        cons
        first
        rest
        isEmpty
        NIL
        foldl
        reverse},
    import 'nu-stream::select' {
        skip}
in {

var flip = \f -> \x y -> f(y, x);

// Context
////////////////////////////////////////
var Context = function(loc, children, constructNode) {
    this.loc = loc;
    this.children = children;
    this.constructNode = constructNode;
};

Context.setLoc = \ctx, loc ->
    new Context(
        loc,
        ctx.children,
        ctx.constructNode);

// Loc
////////////////////////////////////////
var Loc = function(focus, parent, path, left, right) {
    this.focus = focus;
    this.parent = parent;
    this.path = path;
    this.left = left;
    this.right = right;
};

Loc.empty = new Loc(null, null, NIL, NIL, NIL);

Loc.setFocus = \loc, focus ->
    new Loc(
        focus,
        loc.parent,
        loc.path,
        loc.left,
        loc.right);

Loc.setLeft = \loc, left ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        left,
        loc.right);

Loc.setRight = \loc, right ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        loc.left,
        right);

Loc.setSurround = \loc, left, focus, right ->
    Loc.setRight(
        Loc.setLeft(
            Loc.setFocus(loc, focus),
            left),
        right);

/* Internal operations
 ******************************************************************************/
var getLoc = \ctx -> ctx.loc;

var setLoc = \ctx, loc -> Context.setLoc(ctx, loc);

var modifyLoc = \ctx, f -> setLoc(ctx, f(getLoc(ctx)));

var setFocus = \ctx, f -> modifyLoc(ctx, \loc -> Loc.setFocus(loc, f));

var getPath = \ctx -> getLoc(ctx).path;

var pushPath = \x, ctx -> cons(x, getPath(ctx));

/* Reconstruction
 ******************************************************************************/
var construct = \ctx parent children ->
    ctx.constructNode(
        parent,
        children);

var constructParent = \ctx -> 
    construct(ctx,
        parent(ctx).focus,
        append(
            reverse(lefts(ctx)),
            cons(extract(ctx), NIL),
            rights(ctx)));

/* Queries
 ******************************************************************************/
/**
 * Get the focus.
 * 
 * @param ctx
 */
extract = \ctx -> getLoc(ctx).focus;

/**
 * Get ordered path of nodes leading to, and including, the focus.
 * 
 * @return Stream of path, may be infinite.
 */
path = \ctx -> cons(extract(ctx), getPath(ctx));

/**
 * Get ordered list of the focus's left siblings.
 * 
 * The left path is kept in reverse order, with the first element being the
 * element next to the focus.
 * 
 * @return Stream, may be infinite.
 */
lefts = \ctx -> getLoc(ctx).left;

/**
 * Get ordered list of the focus's right siblings.
 * 
 * @return Stream, may be infinite.
 */
rights = \ctx -> getLoc(ctx).right;

/**
 * Get order list of focus's children.
 * 
 * @return Stream of children, may be infinite.
 */
children = \ctx -> ctx.children(extract(ctx));

/**
 * Get the parent of the focus.
 */
parent = \ctx -> getLoc(ctx).parent;

/* Node Predicates
 ******************************************************************************/
/**
 * Does the focus have any children?
 */
hasChildren = children \> (!) <\ isEmpty;

/**
 * Does the focus have a parent?
 */
hasParent = parent \> (!==, null);

/**
 * Is the focus a root node?
 */
isRoot = (!) <\ hasParent;

/**
 * Is the focus a child node?
 */
isChild = hasParent;

/**
 * Is the focus a leaf node?
 */
isLeaf = (!) <\ hasChildren;

/**
 * Is the focus the leftmost of its siblings?
 */
isFirst = lefts \> isEmpty;

/**
 * Is the focus the rightmost of its siblings?
 */
isLast = rights \> isEmpty;

/* Basic Movement
 ******************************************************************************/
/**
 * Move to the parent of the focus.
 * 
 * Returns null if the focus has no parent.
 */
up = \ctx ->
    (isRoot(ctx) ? null :
        setLoc(ctx,
            Loc.setFocus(
                parent(ctx),
                constructParent(ctx))));

/**
 * Move downwards to the leftmost child of the focus.
 * 
 * Returns null if the focus has no children.
 */
down = \ctx ->
    (isLeaf(ctx) ? null :
        setLoc(ctx,
            let cs = children(ctx) in
                new Loc(
                    first(cs),
                    getLoc(ctx),
                    pushPath(extract(ctx), ctx),
                    NIL,
                    rest(cs))));

/**
 * Move left to the next left sibling of the focus.
 * 
 * Returns null if there are no left siblings.
 */
left = \ctx ->
    (isFirst(ctx) ? null :
        setLoc(ctx,
            let ls = lefts(ctx) in
                Loc.setSurround(getLoc(ctx),
                    rest(ls),
                    first(ls),
                    cons(extract(ctx), rights(ctx)))));

/**
 * Move right to the next right sibling of the focus.
 * 
 * Returns null if there are no right siblings.
 */
right = \ctx ->
    (isLast(ctx) ? null :
        setLoc(ctx,
            let rs = rights(ctx) in
                Loc.setSurround(getLoc(ctx),
                    cons(extract(ctx), lefts(ctx)),
                    first(rs),
                    rest(rs))));

/* Compound Movement
 ******************************************************************************/
/**
 * Move to the root of the tree.
 * 
 * Returns the focus if it is the root.
 */
root = \ctx ->
    let parent = up(ctx) in
        (parent ? root(parent) : ctx);

/**
 * Move to the leftmost sibling of the focus.
 * 
 * Returns the focus if it has no left siblings.
 */
leftmost = \ctx ->
    let l = left(ctx) in
        (l ? leftmost(l) : ctx);

/**
 * Move to the rightmost sibling of the focus.
 * 
 * Returns the focus if it has no right siblings.
 */
rightmost = \ctx ->
    let r = right(ctx) in
        (r ? rightmost(r) : ctx);

/**
 * Move to the leftmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
leftLeaf = \ctx ->
    let child = down(ctx) in
        (child ? leftLeaf(child) : ctx);

/**
 * Move to the rightmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
rightLeaf = \ctx ->
    let child = down(ctx) in
        (child ?
            rightLeaf(rightmost(child)) :
            ctx);

/**
 * Move to the next node in a DFS excluding the focus's children.
 * 
 * Returns null if at root.
 */
nextUpDfs = \ctx ->
    let parent = up(ctx) in 
        (parent ?
            (right(parent) || nextUpDfs(parent)) :
            parent);

/**
 * Move to the next node in a DFS traversal.
 */
nextDfs = \ctx ->
    (down(ctx) || right(ctx) || nextUpDfs(ctx));

/**
 * Move to the previous node in a DFS traversal.
 */
prevDfs = \ctx ->
    let l = left(ctx) in
        (l ?
            rightLeaf(l) :
            up(ctx));

/* Editing
 ******************************************************************************/
/**
 * Replace focus with `node`.
 * 
 * @param node Replacement.
 * @param ctx
 */
replace = flip(setFocus);

/**
 * Modify focus with function `f` and replace it with result.
 */
modify = \f, ctx ->
    replace(
        f(extract(ctx)),
        ctx);

/**
 * Removes the focus.
 * 
 * Moves to either the first right sibiling, or the left sibiling, or the parent.
 * 
 * Returns null if the focus has no parent.
 */
remove = \ctx ->
    (isLast(ctx) ?
        (isFirst(ctx) ?
            (hasParent(ctx) ? constructParent(ctx) : null) :
            setRights(NIL, left(ctx))) :
        modifyLefts(
            (skip, 2),
            right(ctx)));

/**
 * Set the lefts of the focus.
 * 
 * @param ls Stream of lefts. Is in reversed order with the first element being
 *   the one next to the focus.
 * @param ctx
 */
setLefts = \ls, ctx ->
    modifyLoc(ctx, \loc -> Loc.setLeft(loc, ls));

/**
 * Modify the current lefts of the focus.
 * 
 * @param  f Mapping current lefts to new lefts.
 * @param ctx
 */
modifyLefts = \f, ctx ->
    setLefts(f(lefts(ctx)), ctx);

/**
 * Set the rights of the focus.
 * 
 * @param ls Stream of rights
 * @param ctx
 */
setRights = \rs, ctx ->
    modifyLoc(ctx, \loc -> Loc.setRight(loc, rs));

/**
 * Modify the rights lefts of the focus.
 * 
 * @param f Mapping current lefts to new lefts.
 * @param ctx
 */
modifyRights = \f, ctx ->
    setRights(f(rights(ctx)), ctx);

/**
 * Insert a sibling to the left of the focus. Stays in the current location.
 */
insertLeft = \node, ctx ->
    modifyLefts((cons, node), ctx);

/**
 * Insert a sibling to the right of the focus. Stays in the current location.
 */
insertRight = \node, ctx ->
    modifyRights((cons, node), ctx);

/**
 * Insert a left child for the focus. Stays in the current location.
 */
insertChild = \node, ctx ->
    (hasChildren(ctx) ?
        (ctx
            |> down
            |> (insertLeft, node)
            |> up) :
        replace(
            construct(ctx, extract(ctx), cons(node, NIL)),
            ctx));

/**
 * Insert a child at the right for the focus. Stays in current location.
 */
appendChild = \node, ctx ->
    (hasChildren(ctx) ?
        (ctx
            |> down
            |> rightmost
            |> (insertRight, node)
            |> up) :
        insertChild(node, ctx));

/* Zipper
 ******************************************************************************/
/**
 * Create a generic zipper.
 * 
 * @param children Maps node to a stream of its children.
 * @param constructNode Maps a base node a node and a stream of its children,
 * to the base node with these children
 * @param focus Starting point and current context for the zipper.
 */
zipper = \children, constructNode, focus ->
    new Context(
        Loc.setFocus(Loc.empty, focus),
        children,
        constructNode);

}