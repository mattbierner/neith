/**
 * @fileOverview Core zipper data structure and generic operations.
 */
package (
// State
    path
    lefts
    rights

// Node Queries
    children
    parent

// Node Predicates
    hasChildren
    hasParent
    isRoot
    isChild
    isLeaf
    isFirst
    isLast

// Basic Movement
    up
    down
    left
    right

// Compound Movement
    whilst
    recur
    
    seq
    any
    
    root
    leftmost
    rightmost
    leftLeaf
    rightLeaf
    
    nextUpDfs
    nextDfs
    prevDfs
    
// Editing
    extract
    replace
    modify
    remove
    setLefts
    modifyLefts
    setRights
    modifyRights
    insertLeft
    insertRight
    insertChild
    appendChild

    detach
// Zipper Creation
    zipper)
with
    import 'nu-stream::stream' {
        append
        cons
        first
        rest
        isEmpty
        NIL
        foldl
        reverse},
    import 'nu-stream::select' {
        skip}
in {

var reduceRight = Function.prototype.call.bind(Array.prototype.reduceRight);

var flip = \f -> \x y -> f(y, x);

// Context
////////////////////////////////////////
var Context = function\loc, children, constructNode =self -> {
    self.loc = loc;
    self.children = children;
    self.constructNode = constructNode;
};

Context.prototype.setLoc = \loc =self->
    new Context(
        loc,
        self.children,
        self.constructNode);

// Loc
////////////////////////////////////////
var Loc = function\focus, parent, path, left, right, dirty =self -> {
    self.focus = focus;
    self.parent = parent;
    self.path = path;
    self.left = left;
    self.right = right;
    self.dirty = dirty;
};

Loc.empty = new Loc(null, null, NIL, NIL, NIL, false);

Loc.prototype.setFocus = \focus =self->
    new Loc(
        focus,
        self.parent,
        self.path,
        self.left,
        self.right,
        self.dirty);

Loc.prototype.setLeft = \left =self->
    new Loc(
        self.focus,
        self.parent,
        self.path,
        left,
        self.right,
        self.dirty);

Loc.prototype.setRight = \right =self->
    new Loc(
        self.focus,
        self.parent,
        self.path,
        self.left,
        right,
        self.dirty);
    
Loc.prototype.setDirty = \dirty =self->
    new Loc(
        self.focus,
        self.parent,
        self.path,
        self.left,
        self.right,
        dirty);

Loc.prototype.setSurround = \left, focus, right =self->
    self
        .setFocus(focus)
        .setLeft(left)
        .setRight(right);

/* Internal operations
 ******************************************************************************/
var getLoc = \ctx -> ctx.loc;

var setLoc = \ctx, loc -> ctx.setLoc(loc);

var modifyLoc = \ctx, f -> setLoc(ctx, f(getLoc(ctx)));

var setFocus = \ctx, f -> modifyLoc(ctx, \loc -> loc.setFocus(f));

var dirty = \ctx -> getLoc(ctx).dirty;

var markDirty = \ctx -> ctx.setLoc(ctx.loc.setDirty(true));

var getPath = \ctx -> getLoc(ctx).path;

var pushPath = \x, ctx -> cons(x, getPath(ctx));

/* Reconstruction
 ******************************************************************************/
var construct = \ctx parent children ->
    ctx.constructNode(
        parent,
        children);

var constructParent = \ctx -> 
    construct(ctx,
        parent(ctx).focus,
        append(
            reverse <| lefts ctx,
            cons(extract ctx, NIL),
            rights ctx));

/* Queries
 ******************************************************************************/
/**
 * Get the focus.
 * 
 * @param ctx
 */
extract = \ctx -> getLoc(ctx).focus;

/**
 * Get ordered path of nodes leading to, and including, the focus.
 * 
 * @return Stream of path, may be infinite.
 */
path = \ctx -> cons(extract ctx, getPath(ctx));

/**
 * Get ordered list of the focus's left siblings.
 * 
 * The left path is kept in reverse order, with the first element being the
 * element next to the focus.
 * 
 * @return Stream, may be infinite.
 */
lefts = \ctx -> getLoc(ctx).left;

/**
 * Get ordered list of the focus's right siblings.
 * 
 * @return Stream, may be infinite.
 */
rights = \ctx -> getLoc(ctx).right;

/**
 * Get order list of focus's children.
 * 
 * @return Stream of children, may be infinite.
 */
children = \ctx -> ctx.children(extract ctx);

/**
 * Get the parent of the focus.
 */
parent = \ctx -> getLoc(ctx).parent;

/* Node Predicates
 ******************************************************************************/
/**
 * Does the focus have any children?
 */
hasChildren = children \> (!) <\ isEmpty;

/**
 * Does the focus have a parent?
 */
hasParent = parent \> (!==)@null;

/**
 * Is the focus a root node?
 */
isRoot = (!) <\ hasParent;

/**
 * Is the focus a child node?
 */
isChild = hasParent;

/**
 * Is the focus a leaf node?
 */
isLeaf = (!) <\ hasChildren;

/**
 * Is the focus the leftmost of its siblings?
 */
isFirst = lefts \> isEmpty;

/**
 * Is the focus the rightmost of its siblings?
 */
isLast = rights \> isEmpty;

/* Basic Movement
 ******************************************************************************/
/**
 * Move to the parent of the focus.
 * 
 * Returns null if the focus has no parent.
 */
up = \ctx ->
    ?isRoot ctx
        :null
        :setLoc(ctx,
            ?dirty ctx
                :parent(ctx)
                    .setFocus(constructParent(ctx))
                    .setDirty(true)
                :parent(ctx));

/**
 * Move downwards to the leftmost child of the focus.
 * 
 * Returns null if the focus has no children.
 */
down = \ctx -> let
    cs = children ctx
in
    ?isEmpty cs
        :null
        :setLoc(ctx,
            new Loc(
                first cs,
                getLoc(ctx),
                pushPath(extract ctx, ctx),
                NIL,
                rest cs,
                false));

/**
 * Move left to the next left sibling of the focus.
 * 
 * Returns null if there are no left siblings.
 */
left = \ctx ->
    ?isFirst ctx
        :null
        :let ls = lefts ctx in
            setLoc(ctx,
                getLoc(ctx).setSurround(
                    rest ls,
                    first ls,
                    cons(extract ctx, rights ctx)));

/**
 * Move right to the next right sibling of the focus.
 * 
 * Returns null if there are no right siblings.
 */
right = \ctx ->
    ?isLast ctx
        :null
        :let rs = rights ctx in
            setLoc(ctx,
                getLoc(ctx).setSurround(
                    cons(extract ctx, lefts ctx),
                    first rs,
                    rest rs));

/* Compound Movement
 ******************************************************************************/
/**
 * Run `op` while `pred` holds true, returning the last result.
 * 
 * @param pred Predicate operation taking current context.
 * @param op Movement operation that updates the context..
 * @param ctx
 */
whilst = \pred op ctx ->
    ?ctx && pred ctx
        :whilst(pred, op, op ctx)
        :ctx;

/**
 * Run `op` until it fails, returning the last successful result.
 * 
 * @param op Movement operation mapping a context to a new context or null.
 * @param ctx
 */
recur = \op ctx ->
    let next = op ctx in
        ?next
            :recur(op, next)
            :ctx;

/**
 * Perform a set of operations left to right. Returns result from first to fail or last operations.
 * 
 * Takes list of operations as arguments.
 */
seq = let
    and = \p, c ->
        \ctx ->
            let next = c ctx in
                ?next
                    :p(next)
                    :next
in
    \ops(...) ->
        reduceRight(ops, and);

/**
 * Perform a set of operations left to right. Returns result from first to succeed.
 * 
 * Takes list of operations as arguments.
 */
any = let
    or = \p, c -> \ctx -> c ctx || p ctx
in
    \ops(...) ->
        reduceRight(ops, or);

/**
 * Move to the root of the tree.
 * 
 * Returns the focus if it is the root.
 */
root = recur@up;

/**
 * Move to the leftmost sibling of the focus.
 * 
 * Returns the focus if it has no left siblings.
 */
leftmost = recur@left;

/**
 * Move to the rightmost sibling of the focus.
 * 
 * Returns the focus if it has no right siblings.
 */
rightmost = recur@right;

/**
 * Move to the leftmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
leftLeaf = recur@down;

/**
 * Move to the rightmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
rightLeaf = recur@seq(down, rightmost);

/**
 * Move to the next node in a DFS excluding the focus's children.
 * 
 * Returns null if at root.
 */
nextUpDfs = \ctx ->
    let parent = up ctx in 
        ?parent
            :(right parent || nextUpDfs parent)
            :parent;

/**
 * Move to the next node in a DFS traversal.
 */
nextDfs = any(down, right, nextUpDfs);

/**
 * Move to the previous node in a DFS traversal.
 */
prevDfs = \ctx ->
    let l = left ctx in
        ?l
            :rightLeaf l
            :up ctx;

/* Editing
 ******************************************************************************/
/**
 * Replace focus with `node`.
 * 
 * @param node Replacement.
 * @param ctx
 */
replace = flip setFocus \>> markDirty;

/**
 * Modify focus with function `f` and replace it with result.
 */
modify = \f, ctx ->
    replace(
        f(extract ctx),
        ctx);

/**
 * Removes the focus.
 * 
 * Moves to either the first right sibiling, or the left sibiling, or the parent.
 * 
 * Returns null if the focus has no parent.
 */
remove = \ctx ->
    ?isLast ctx
        :?isFirst ctx
            :?hasParent ctx :constructParent ctx :null
            :setRights(NIL, left ctx)
        :modifyLefts(
            skip@1,
            right ctx);

/**
 * Set the lefts of the focus.
 * 
 * @param ls Stream of lefts. Is in reversed order with the first element being
 *   the one next to the focus.
 * @param ctx
 */
setLefts =\ls, ctx ->
    modifyLoc(ctx, \loc -> loc.setLeft(ls).setDirty(true));

/**
 * Modify the current lefts of the focus.
 * 
 * @param  f Mapping current lefts to new lefts.
 * @param ctx
 */
modifyLefts = \f, ctx ->
    setLefts(f(lefts ctx), ctx);

/**
 * Set the rights of the focus.
 * 
 * @param ls Stream of rights
 * @param ctx
 */
setRights = \rs, ctx ->
    modifyLoc(ctx, \loc -> loc.setRight(rs).setDirty(true));

/**
 * Modify the rights lefts of the focus.
 * 
 * @param f Mapping current lefts to new lefts.
 * @param ctx
 */
modifyRights = \f, ctx ->
    setRights(f(rights ctx), ctx);

/**
 * Insert a sibling to the left of the focus. Stays in the current location.
 */
insertLeft = \node, ctx ->
    modifyLefts(cons@node, ctx);

/**
 * Insert a sibling to the right of the focus. Stays in the current location.
 */
insertRight = \node, ctx ->
    modifyRights(cons@node, ctx);

/**
 * Insert a left child for the focus. Stays in the current location.
 */
insertChild = \node, ctx ->
    ?hasChildren ctx
        :ctx
            |> down
            |> insertLeft@node
            |> up
        :replace(
            construct(ctx, extract ctx, cons(node, NIL)),
            ctx);

/**
 * Insert a child at the right for the focus. Stays in current location.
 */
appendChild = \node, ctx ->
    ?hasChildren ctx
        :ctx
            |> down
            |> rightmost
            |> insertRight@node
            |> up
        :insertChild(node, ctx);

/* Context editing
 ******************************************************************************/
/**
 * Treat the current node as the root of the zipper.
 */
detach = \ctx ->
    setLoc(ctx,
        Loc.empty.setFocus(extract ctx));

/* Zipper
 ******************************************************************************/
/**
 * Create a generic zipper.
 * 
 * @param children Maps node to a stream of its children.
 * @param constructNode Maps a base node a node and a stream of its children,
 * to the base node with these children
 * @param focus Starting point and current context for the zipper.
 */
zipper = \children, constructNode, focus ->
    new Context(
        Loc.empty.setFocus(focus),
        children,
        constructNode);

}