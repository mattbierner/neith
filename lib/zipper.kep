/**
 * @fileOverview Zipper structures and operations.
 */
package (
    Loc,
    Context,
    
// State
    path,
    lefts,
    rights,

// Node Queries
    getChildren,
    getChild,
    getParent,
    
// Node Predicates
    hasChildren,
    hasParent,
    isRoot,
    isChild,
    isLeaf,
    isFirst,
    isLast,
    
// Basic Movement
    up,
    down,
    left,
    right,

// Compound Movement
    root,
    leftmost,
    rightmost,
    leftLeaf,
    rightLeaf,
    
    nextUpDfs,
    nextDfs,
    prevDfs,
    
// Labeled Movement
    child,
    nthChild,
    sibling,
    
// Editing
    getNode,
    setNode,
    modifyNode,
    removeNode,
    insertLeft,
    insertRight,
    insertChild,
    appendChild,

// Zipper Creation
    zipper,
    treeZipper)
{
var call = Function.prototype.bind.bind(Function.prototype.call);

var concat = call(Array.prototype.concat);
var map = call(Array.prototype.map);
var slice = call(Array.prototype.slice);
var reduce = call(Array.prototype.reduce);

/* Context
 ******************************************************************************/
var Pair = \key, value -> ({'key': key, 'value': value});

/* Context
 ******************************************************************************/
/**
 * 
 */
Context = function(loc, getChildren, getChild, constructNode) {
    this.loc = loc;
    this.getChildren = getChildren;
    this.getChild = getChild;
    this.constructNode = constructNode;
};

Context.setLoc = \ctx, loc ->
    new Context(
        loc,
        ctx.getChildren,
        ctx.getChild,
        ctx.constructNode);

/* Loc
 ******************************************************************************/
/**
 * 
 */
Loc = function(focus, parent, path, left, right) {
    this.focus = focus;
    this.parent = parent;
    this.path = path;
    this.left = left;
    this.right = right;
};

Loc.empty = new Loc(null, null, [], [], []);

Loc.setFocus = \loc, focus ->
    new Loc(
        focus,
        loc.parent,
        loc.path,
        loc.left,
        loc.right);

Loc.setLeft = \loc, left ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        left,
        loc.right);

Loc.setRight = \loc, right ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        loc.left,
        right);

/* Internal operations
 ******************************************************************************/
var getLoc = \ctx -> ctx.loc;

var setLoc = \ctx, loc -> Context.setLoc(ctx, loc);

var modifyLoc = \ctx, f -> setLoc(ctx, f(getLoc(ctx)));

var setFocus = \ctx, f -> modifyLoc(ctx, \loc -> Loc.setFocus(loc, f));

var setLefts = \ctx, ls -> modifyLoc(ctx, \loc -> Loc.setLeft(loc, ls));

var setRights = \ctx, rs -> modifyLoc(ctx, \loc -> Loc.setRight(loc, rs));

var modifyLefts = \ctx, f -> setLefts(ctx, f(ctx.loc.left));

var modifyRights = \ctx, f -> setRights(ctx, f(ctx.loc.right));

var getFocus = \ctx -> getLoc(ctx).focus;

/* Context Operations
 ******************************************************************************/
var pushPath = \x, ctx -> concat([x], path(ctx));

var popPath = \ctx -> slice(path(ctx), 1);

var setPath = \x, ctx ->
    concat(x, slice(path(ctx, 1)));

/* Reconstruction
 ******************************************************************************/
var construct = let
    m = \x -> x.key,
    reducer = \p, c -> {
        p[c.key] = c.value;
        return p;
    }
in
    \ctx, parent, children ->
        ctx.constructNode(
            parent,
            map(children, m),
            reduce(children, reducer, {}));

var constructParent = \ctx -> 
    construct(ctx,
        getParent(ctx).focus,
        concat(
            ctx.loc.left,
            Pair(ctx.loc.path[0], ctx.loc.focus),
            ctx.loc.right));

/* Context Query
 ******************************************************************************/
/**
 * Get ordered path to the focus.
 * 
 * Paths are stored in reverse order, with the first item being the edge leading
 * from the focus's parent to the focus.
 */
path = \ctx -> getLoc(ctx).path;

/**
 * Get ordered list of the focus's left siblings.
 */
lefts = \ctx -> getLoc(ctx).left;

/**
 * Get ordered list of the focus's right siblings.
 */
rights = \ctx -> getLoc(ctx).right;

/* Node Queries 
 ******************************************************************************/
/**
 * Get order list of focus's child edges.
 */
getChildren = \ctx -> ctx.getChildren(getFocus(ctx));

/**
 * Get the child node for `edge` of focus.
 */
getChild = \ctx, edge -> ctx.getChild(getFocus(ctx), edge);

/**
 * Get the parent of the focus.
 */
getParent = \ctx -> getLoc(ctx).parent;

/* Node Predicates
 ******************************************************************************/
/**
 * Does the focus have any children?
 */
hasChildren = \ctx -> !!getChildren(ctx).length;

/**
 * Does the focus have a parent?
 */
hasParent = \ctx -> getParent(ctx) !== null;

/**
 * Is the focus a root node?
 */
isRoot = hasParent \> (!);

/**
 * Is the focus a child node?
 */
isChild = hasParent;

/**
 * Is the focus a leaf node?
 */
isLeaf = hasChildren \> (!);

/**
 * Is the focus the leftmost of its siblings?
 */
isFirst = \ctx -> lefts(ctx).length === 0;

/**
 * Is the focus the rightmost of its siblings?
 */
isLast = \ctx -> rights(ctx).length === 0;

/* Basic Movement
 ******************************************************************************/
/**
 * Move to the parent of the focus.
 * 
 * Returns null if the focus has no parent.
 */
up = \ctx ->
    (!hasParent(ctx) ? null :
        setLoc(ctx,
            Loc.setFocus(
                getParent(ctx),
                constructParent(ctx))));

/**
 * Move downwards to the leftmost child of the focus.
 * 
 * Returns null if the focus has no children.
 * 
 * This is an order dependent operation.
 */
down = \ctx ->
    (!hasChildren(ctx) ? null :
        let
            children[child] = getChildren(ctx)
        in
            setLoc(
                ctx,
                new Loc(
                    getChild(ctx, child),
                    getLoc(ctx),
                    pushPath(child, ctx),
                    [],
                    slice(children, 1).map(\x -> Pair(x, getChild(ctx, x))))));

/**
 * Move left to the next left sibling of the focus.
 * 
 * Returns null if there are no left siblings.
 * 
 * This is an order dependent operation.
 */
left = \ctx -> let
    ls[l] = lefts(ctx)
in
    (!ls.length ? null :
        setLoc(ctx,
            new Loc(
                l.value,
                getParent(ctx),
                setPath(l.key, ctx),
                slice(ctx.loc.left, 1),
                concat(
                    Pair(path(ctx)[0], getFocus(ctx)),
                    ctx.loc.right))));

/**
 * Move right to the next right sibling of the focus.
 * 
 * Returns null if there are no right siblings.
 * 
 * This is an order dependent operation.
 */
right = \ctx -> let
    rs[r] = rights(ctx)
in
    (!rs.length ? null :
        setLoc(ctx,
            new Loc(
                r.value,
                getParent(ctx),
                setPath(r.key, ctx),
                concat(ctx.loc.left, Pair(path(ctx)[0], getFocus(ctx))),
                slice(ctx.loc.right, 1))));

/* Compound Movement
 ******************************************************************************/
/**
 * Move to the root of the tree.
 * 
 * Returns the focus if it is the root.
 */
root = \ctx ->
    let parent = up(ctx) in
        (parent ? root(parent) : ctx);

/**
 * Move to the leftmost sibling of the focus.
 * 
 * Returns the focus if it has no left siblings.
 */
leftmost = \ctx ->
    let l = left(ctx) in
        (l ? leftmost(l) : ctx);

/**
 * Move to the rightmost sibling of the focus.
 * 
 * Returns the focus if it has no right siblings.
 */
rightmost = \ctx ->
    let r = right(ctx) in
        (r ? rightmost(r) : ctx);

/**
 * Move to the leftmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
leftLeaf = \ctx ->
    let child = down(ctx) in
        (child ?
            leftLeaf(child) :
            ctx);

/**
 * Move to the rightmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
rightLeaf = \ctx ->
    let child = down(ctx) in
        (child ?
            rightLeaf(rightmost(child)) :
            ctx);

/**
 * Move to the next node in a DFS excluding the focus's children.
 * 
 * Returns null if at root.
 */
nextUpDfs = \ctx ->
    let parent = up(ctx) in 
        (parent ?
            (right(parent) || nextUpDfs(parent)) :
            parent);

/**
 * Move to the next node in a DFS traversal.
 */
nextDfs = \ctx ->
    (down(ctx) || right(ctx) || nextUpDfs(ctx));

/**
 * Move to the previous node in a DFS traversal.
 */
prevDfs = \ctx ->
    let l = left(ctx) in
        (l ?
            rightLeaf(l) :
            up(ctx));

/* Labeled Movement
 ******************************************************************************/
/**
 * Move to the nth child of focus.
 * 
 * Returns null if no such child exists.
 * 
 * This is an order dependant operation.
 * 
 * @param index Index of child to move to.
 */
nthChild = let
    goRight = \ctx, count ->
        (count <= 0 ?
            ctx :
            goRight(right(ctx), count - 1))
in
    \index, ctx ->
        let child = down(ctx) in
            (child ?
                goRight(child, index) :
                child);

/**
 * Move to the child from `edge` of focus.
 * 
 * Returns null if no such child exists.
 * 
 * This is an order independent operation.
 * 
 * @param edge Label of edge to move on.
 */
child = \edge, ctx -> let
    children = getChildren(ctx),
    index = children.indexOf(edge)
in
    (index === -1 ? null :
        nthChild(index, ctx));

/**
 * Move to the sibling with `edge` leading from the focus's parent.
 * 
 * Returns null if no such sibling exists. Returns the focus if `edge`
 * leads to it.
 * 
 * This is an order independent operation.
 * 
 * @param edge Label of edge to move on.
 */
sibling = \edge, ctx ->
    (ctx
        |> up
        |> (child, edge));

/* Editing
 ******************************************************************************/
/**
 * Get the focus.
 */
getNode = getFocus;

/**
 * Replace focus with `node`.
 */
setNode = \node, ctx -> setFocus(ctx, node);

/**
 * Modify focus with function `f` and replace it with result.
 */
modifyNode = \f, ctx ->
    setNode(
        f(getNode(ctx)),
        ctx);

/**
 * Removes the focus. Moves to either the first right sibiling, or the
 * first right sibiling or the parent.
 * 
 * Returns null if the focus has no parent.
 */
removeNode = \ctx ->
    (!hasParent(ctx) ? null :
        (isLast(ctx) ?
            (isFirst(ctx) ?
                construct(ctx, ctx.loc.parent, []) :
                setRights(left(ctx), [])) :
            modifyLefts(
                right(ctx),
                \lefts -> slice(lefts, 0 , lefts.length - 2))));

/**
 * Insert a sibling to the left of the focus. Stays in the current location.
 */
insertLeft = \name, node, ctx ->
    modifyLefts(ctx, \ls ->
        concat(
            ls,
            Pair(name, node)));

/**
 * Insert a sibling to the right of the focus. Stays in the current location.
 */
insertRight = \edge, node, ctx ->
    modifyRights(ctx, \rs ->
        concat(
            Pair(edge, node),
            rs));

/**
 * Insert a child at the left for the focus. Stays in the current location..
 */
insertChild = \edge, node, ctx ->
    (ctx
        |> down
        |> (insertLeft, edge, node)
        |> up);
/**
 * Insert a child at the right for the focus. Stays in current location.
 */
appendChild = \edge, node, ctx ->
    (hasChildren(ctx) ?
        (ctx
            |> down
            |> rightmost
            |> (insertRight, edge, node)
            |> up) :
        setNode(
            construct(ctx, ctx.loc.focus, [Pair(edge, node)]),
            ctx));

/* Zipper
 ******************************************************************************/
/**
 * Create a generic zipper.
 * 
 * @param edges Function taking a node and returning an array of edges
 *     the children of this node.
 * @param getChild Function taking a node and key and returning the child.
 * @param constructNode Function taking a node and map of keys to children and returns
 *    a new node from these children.
 * @param focus Starting point and current context for the zipper.
 */
zipper = \edges, getChild, constructNode, focus ->
    new Context(
        Loc.setFocus(Loc.empty, focus),
        edges,
        getChild,
        constructNode);

/**
 * Create a zipper for a tree with child edges stored on the node.
 */
treeZipper = let
    getChild = \obj, key -> obj[key]
in
    \edges, construct, root ->
        zipper(
            edges,
            getChild,
            construct,
            root);
}