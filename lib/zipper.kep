/**
 * @fileOverview
 */
static define;
define([],
function() {
//"use strict";

var call = Function.prototype.bind.bind(Function.prototype.call);

var concat = call(Array.prototype.concat);
var map = call(Array.prototype.map);
var slice = call(Array.prototype.slice);
var reduce = call(Array.prototype.reduce);

/* Context
 ******************************************************************************/
var Pair = \key, value -> ({'key': key, 'value': value});

/* Context
 ******************************************************************************/
/**
 * 
 */
var Context = function(loc, getChildren, getChild, constructNode) {
    this.loc = loc;
    this.getChildren = getChildren;
    this.getChild = getChild;
    this.constructNode = constructNode;
};

Context.setLoc = \ctx, loc ->
    new Context(
        loc,
        ctx.getChildren,
        ctx.getChild,
        ctx.constructNode);

/* Loc
 ******************************************************************************/
// Loc
////////////////////////////////////////
/**
 * 
 */
var Loc = function(focus, parent, path, left, right) {
    this.focus = focus;
    this.parent = parent;
    this.path = path;
    this.left = left;
    this.right = right;
};

Loc.setFocus = \loc, focus ->
    new Loc(
        focus,
        loc.parent,
        loc.path,
        loc.left,
        loc.right);

/* Basic Operators
 ******************************************************************************/
var getLoc = \ctx -> ctx.loc;

var getFocus = \ctx -> getLoc(ctx).focus;

var getChildren = \ctx -> ctx.getChildren(getFocus(ctx));

var hasChildren = \ctx -> !!getChildren(ctx).length;

var getChild = \ctx, key -> ctx.getChild(getFocus(ctx), key);

var getParent = \ctx -> getLoc(ctx).parent;

var hasParent = \ctx -> getLoc(ctx).parent !== null;

var getPath = \ctx -> getLoc(ctx).path;

var pushPath = \ctx, x -> concat([x], getPath(ctx));

var popPath = \ctx -> slice(getPath(ctx), 1);

var construct = \ctx, parent, children ->
    ctx.constructNode(ctx, parent, children);

var constructParent = \ctx -> 
    ctx.constructNode(
        getParent(ctx).focus,
        concat(ctx.loc.left, Pair(ctx.loc.path[0], ctx.loc.focus), ctx.loc.right)
            .reduce(\p, c -> { p[c.key] = c.value; return p; }, {}));

/* 
 ******************************************************************************/
/**
 * Get ordered path to the current node.

 */
var path = \ctx -> getLoc(ctx).left;

/**
 * Get ordered list of the current node's left siblings.

 */
var lefts = \ctx -> getLoc(ctx).left;

/**
 * Get ordered list of the current node's right siblings.
 */
var rights = \ctx -> getLoc(ctx).right;

/* Primitive Movement
 ******************************************************************************/
/**
 * Move to the parent of the current node.
 * 
 * Returns null if the current node has no parent.
 */
var up = \ctx ->
    (!hasParent(ctx) ? null :
        Context.setLoc(
            ctx,
            Loc.setFocus(
                getParent(ctx),
                constructParent(ctx))));

/**
 * Move downwards to the leftmost child of the current node.
 * 
 * Returns null if the current node has no children.
 */
var down = \ctx ->
    (!hasChildren(ctx) ? null :
        let
            children = getChildren(ctx)
        in
            Context.setLoc(
                ctx,
                new Loc(
                    getChild(ctx, children[0]),
                    getLoc(ctx),
                    pushPath(ctx, children[0]),
                    [],
                    children.slice(1).map(\x -> Pair(x, getChild(ctx, x))))));

/**
 * Move left to the next left sibling of the current node.
 * 
 * Returns null if there are no left siblings.
 */
var left = \loc -> loc;/*
    (loc.left.length ?
        let
            key = loc.left[loc.left.length - 1]
        in
            new Loc(
                loc.focus[key],
                setKey(loc.path, key),
                loc.left.slice(loc.left.length - 1),
                [loc.path[0].key].concat(loc.right)) :
        null);*/

/**
 * Move right to the next right sibling of the current node.
 * 
 * Returns null if there are no right siblings.
 */
var right = \ctx ->
    let
        rs = rights(ctx),
        r = rs[0]
    in
        (!rs.length ? null :
            Context.setLoc(ctx, new Loc(
                r.value,
                getParent(ctx),
                concat([r.key], slice(getPath(ctx, 1))),
                concat(ctx.loc.left, Pair(getPath(ctx)[0], getFocus(ctx))),
                slice(ctx.loc.right, 1))));

/*
 ******************************************************************************/

/* Compound Movement
 ******************************************************************************/
/**
 * Move to the root of the tree.
 * 
 * Returns the current node if it is the root.
 */
var root = \ctx ->
    let parent = up(ctx) in
        (parent ? root(parent) : ctx);

/**
 * Move to the leftmost sibling of the current node.
 * 
 * Returns the current node if it has no left siblings.
 */
var leftmost = \ctx ->
    let l = left(ctx) in
        (l ? leftmost(l) : ctx);

/**
 * Move to the rightmost sibling of the current node.
 * 
 * Returns the current node if it has not right are no left siblings.
 */
var rightmost = \ctx ->
    let r = right(ctx) in
        (r ? rightmost(r) : ctx);

/* Labeled Movement
 ******************************************************************************/


/* Basic Editing
 ******************************************************************************/
/**
 * Get the current node.
 */
var getNode = getFocus;

/**
 * Replace current node with `node`.
 */
var setNode = \ctx, node ->
    Context.setLoc(ctx, Loc.setFocus(getLoc(ctx), node));

/**
 * Modify current node with function `f` and replace it with result.
 */
var modifyNode = \ctx, f ->
    setNode(ctx, f(getNode(ctx)));

/**
 * 
 */
var insertLeft;


var insertRight;

/**
 * 
 */
var insertChild;

/**
 * 
 */
var appendChild;


/* Zippers
 ******************************************************************************/
/**
 * Create a generic zipper.
 * 
 * @param focus Starting point and current context for the zipper.
 * @param getChildren Function taking a node and returning an array of keys
 *     for the children of this node.
 * @param getChild Function taking a node and key and returning the child.
 * @param makeNode Function taking a node and map of keys to children and returns
 *    a new node from these children.
 */
var zipper = \root, getChildren, getChild, constructNode ->
    new Context(
        new Loc(root, null, [], [], []),
        getChildren,
        getChild,
        constructNode);

/**
 * Create a zipper for a tree.
 */
var treeZipper = let
    getChildren = \x -> x.children,
    getChild = \x, k -> x[k],
    constructNode = \x, children -> x.construct(x, children)
in
    \root -> zipper(root, getChildren, getChild, constructNode);

/* Export
 ******************************************************************************/
return {
    'Loc': Loc,
    
// Primitive Movement
    'up': up,
    'down': down,
    'left': left,
    'right': right,

// Compound Movement
    'root': root,
    'leftmost': leftmost,
    'rightmost': rightmost,

// Editing
    'getNode': getNode,
    'setNode': setNode,
    'modifyNode': modifyNode,
    
// State
    'lefts': lefts,
    'rights': rights,

// Zipper Creation
    'zipper': zipper,
    'treeZipper': treeZipper
};

});