/**
 * @fileOverview Zipper structures and operations.
 */
package (
// State
    path,
    lefts,
    rights,

// Node Queries
    getChildren,
    getChild,
    getParent,
    
// Node Predicates
    hasChildren,
    hasParent,
    isRoot,
    isChild,
    isLeaf,
    isFirst,
    isLast,
    
// Basic Movement
    up,
    down,
    left,
    right,

// Compound Movement
    root,
    leftmost,
    rightmost,
    leftLeaf,
    rightLeaf,
    
    nextUpDfs,
    nextDfs,
    prevDfs,
    
// Labeled Movement
    child,
    nthChild,
    sibling,
    
// Editing
    getNode,
    setNode,
    modifyNode,
    removeNode,
    insertLeft,
    insertRight,
    insertChild,
    appendChild,

// Zipper Creation
    zipper,
    treeZipper)
with
    import 'nu/stream' stream{first, rest, isEmpty, 'end': NIL, foldl},
    import 'nu/select' {skip}
in {

var call = Function.prototype.bind.bind(Function.prototype.call);

var concat = call(Array.prototype.concat);
var map = call(Array.prototype.map);
var slice = call(Array.prototype.slice);
var reduce = call(Array.prototype.reduce);

var indexOf = \e, s ->
    foldl(
        \p, c, i ->
            (p >= 0 ? p : (c === e ? i : p)),
        -1,
        s);

/* Records
 ******************************************************************************/
var Pair = \key, value -> ({'key': key, 'value': value});

var key = \x -> x.key;

var value = \x -> x.value;

// Context
////////////////////////////////////////
var Context = function(loc, getChildren, getChild, constructNode) {
    this.loc = loc;
    this.getChildren = getChildren;
    this.getChild = getChild;
    this.constructNode = constructNode;
};

Context.setLoc = \ctx, loc ->
    new Context(
        loc,
        ctx.getChildren,
        ctx.getChild,
        ctx.constructNode);

// Loc
////////////////////////////////////////
var Loc = function(focus, parent, path, left, right) {
    this.focus = focus;
    this.parent = parent;
    this.path = path;
    this.left = left;
    this.right = right;
};

Loc.empty = new Loc(null, null, NIL, NIL, NIL);

Loc.setFocus = \loc, focus ->
    new Loc(
        focus,
        loc.parent,
        loc.path,
        loc.left,
        loc.right);

Loc.setLeft = \loc, left ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        left,
        loc.right);

Loc.setRight = \loc, right ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        loc.left,
        right);

/* Internal operations
 ******************************************************************************/
var getLoc = \ctx -> ctx.loc;

var setLoc = \ctx, loc -> Context.setLoc(ctx, loc);

var modifyLoc = \ctx, f -> setLoc(ctx, f(getLoc(ctx)));

var setFocus = \ctx, f -> modifyLoc(ctx, \loc -> Loc.setFocus(loc, f));

var setLefts = \ctx, ls -> modifyLoc(ctx, \loc -> Loc.setLeft(loc, ls));

var setRights = \ctx, rs -> modifyLoc(ctx, \loc -> Loc.setRight(loc, rs));

var modifyLefts = \ctx, f -> setLefts(ctx, f(ctx.loc.left));

var modifyRights = \ctx, f -> setRights(ctx, f(ctx.loc.right));

var getFocus = \ctx -> getLoc(ctx).focus;

/* Context Operations
 ******************************************************************************/
var pushPath = \x, ctx -> stream.cons(x, path(ctx));

var popPath = path \> rest;

var setPath = \x, ctx -> stream.cons(x, rest(path(ctx)));

/* Reconstruction
 ******************************************************************************/
var construct = let
    reducer = \p, c -> {
        p[key(c)] = value(c);
        return p;
    }
in
    \ctx, parent, children ->
        ctx.constructNode(
            parent,
            stream.toArray(stream.map(key, children)),
            stream.foldl(reducer, {}, children));

var constructParent = \ctx -> 
    construct(ctx,
        getParent(ctx).focus,
        stream.append(
            ctx.loc.left,
            stream.cons(Pair(first(ctx.loc.path), getFocus(ctx)), NIL),
            ctx.loc.right));

/* Context Query
 ******************************************************************************/
/**
 * Get ordered path to the focus.
 * 
 * Paths are stored in reverse order, with the first item being the edge leading
 * from the focus's parent to the focus.
 */
path = \ctx -> getLoc(ctx).path;

/**
 * Get ordered list of the focus's left siblings.
 */
lefts = \ctx -> getLoc(ctx).left;

/**
 * Get ordered list of the focus's right siblings.
 */
rights = \ctx -> getLoc(ctx).right;

/* Node Queries 
 ******************************************************************************/
/**
 * Get order list of focus's child edges.
 */
getChildren = \ctx -> let
    children  = ctx.getChildren(getFocus(ctx))
in
    (Array.isArray(children) ?
        stream.from(children) :
        children);

/**
 * Get the child node for `edge` of focus.
 */
getChild = \edge, ctx -> ctx.getChild(getFocus(ctx), edge);

/**
 * Get the parent of the focus.
 */
getParent = \ctx -> getLoc(ctx).parent;

/* Node Predicates
 ******************************************************************************/
/**
 * Does the focus have any children?
 */
hasChildren = getChildren \> (!) <\ isEmpty;

/**
 * Does the focus have a parent?
 */
hasParent = getParent \> (!==, null);

/**
 * Is the focus a root node?
 */
isRoot = (!) <\ hasParent;

/**
 * Is the focus a child node?
 */
isChild = hasParent;

/**
 * Is the focus a leaf node?
 */
isLeaf = (!) <\ hasChildren;

/**
 * Is the focus the leftmost of its siblings?
 */
isFirst = lefts \> isEmpty;

/**
 * Is the focus the rightmost of its siblings?
 */
isLast = rights \> isEmpty;

/* Basic Movement
 ******************************************************************************/
/**
 * Move to the parent of the focus.
 * 
 * Returns null if the focus has no parent.
 */
up = \ctx ->
    (!hasParent(ctx) ? null :
        setLoc(ctx,
            Loc.setFocus(
                getParent(ctx),
                constructParent(ctx))));

/**
 * Move downwards to the leftmost child of the focus.
 * 
 * Returns null if the focus has no children.
 * 
 * This is an order dependent operation.
 */
down = \ctx ->
    (!hasChildren(ctx) ? null :
        let
            children = getChildren(ctx),
            child = first(children)
        in
            setLoc(ctx,
                new Loc(
                    getChild(child, ctx),
                    getLoc(ctx),
                    pushPath(child, ctx),
                    NIL,
                    stream.map(\x -> Pair(x, getChild(x, ctx)), rest(children)))));

/**
 * Move left to the next left sibling of the focus.
 * 
 * Returns null if there are no left siblings.
 * 
 * This is an order dependent operation.
 */
left = \ctx -> let
    ls = lefts(ctx)
in
    (isEmpty(ls) ? null :
        let l = first(ls) in
            setLoc(ctx,
                new Loc(
                    value(l),
                    getParent(ctx),
                    setPath(key(l), ctx),
                    rest(lefts(ctx)),
                    stream.cons(
                        Pair(first(path(ctx)), getFocus(ctx)),
                        rights(ctx)))));

/**
 * Move right to the next right sibling of the focus.
 * 
 * Returns null if there are no right siblings.
 * 
 * This is an order dependent operation.
 */
right = \ctx -> let
    rs = rights(ctx)
in
    (isEmpty(rs) ? null :
        let r = first(rs) in
            setLoc(ctx,
                new Loc(
                    value(r),
                    getParent(ctx),
                    setPath(key(r), ctx),
                    stream.append(
                        lefts(ctx),
                        stream.cons(Pair(first(path(ctx)), getFocus(ctx)), NIL)),
                    rest(rights(ctx)))));

/* Compound Movement
 ******************************************************************************/
/**
 * Move to the root of the tree.
 * 
 * Returns the focus if it is the root.
 */
root = \ctx ->
    let parent = up(ctx) in
        (parent ? root(parent) : ctx);

/**
 * Move to the leftmost sibling of the focus.
 * 
 * Returns the focus if it has no left siblings.
 */
leftmost = \ctx ->
    let l = left(ctx) in
        (l ? leftmost(l) : ctx);

/**
 * Move to the rightmost sibling of the focus.
 * 
 * Returns the focus if it has no right siblings.
 */
rightmost = \ctx ->
    let r = right(ctx) in
        (r ? rightmost(r) : ctx);

/**
 * Move to the leftmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
leftLeaf = \ctx ->
    let child = down(ctx) in
        (child ? leftLeaf(child) : ctx);

/**
 * Move to the rightmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
rightLeaf = \ctx ->
    let child = down(ctx) in
        (child ?
            rightLeaf(rightmost(child)) :
            ctx);

/**
 * Move to the next node in a DFS excluding the focus's children.
 * 
 * Returns null if at root.
 */
nextUpDfs = \ctx ->
    let parent = up(ctx) in 
        (parent ?
            (right(parent) || nextUpDfs(parent)) :
            parent);

/**
 * Move to the next node in a DFS traversal.
 */
nextDfs = \ctx ->
    (down(ctx) || right(ctx) || nextUpDfs(ctx));

/**
 * Move to the previous node in a DFS traversal.
 */
prevDfs = \ctx ->
    let l = left(ctx) in
        (l ?
            rightLeaf(l) :
            up(ctx));

/* Labeled Movement
 ******************************************************************************/
/**
 * Move to the nth child of focus.
 * 
 * Returns null if no such child exists.
 * 
 * This is an order dependant operation.
 * 
 * @param index Index of child to move to.
 */
nthChild = let
    goRight = \ctx, count ->
        (count <= 0 ?
            ctx :
            goRight(right(ctx), count - 1))
in
    \index, ctx ->
        let child = down(ctx) in
            (child ?
                goRight(child, index) :
                child);

/**
 * Move to the child from `edge` of focus.
 * 
 * Returns null if no such child exists.
 * 
 * This is an order independent operation.
 * 
 * @param edge Label of edge to move on.
 */
child = \edge, ctx -> let
    children = getChildren(ctx),
    index = indexOf(edge, children)
in
    (index === -1 ? null :
        nthChild(index, ctx));

/**
 * Move to the sibling with `edge` leading from the focus's parent.
 * 
 * Returns null if no such sibling exists. Returns the focus if `edge`
 * leads to it.
 * 
 * This is an order independent operation.
 * 
 * @param edge Label of edge to move on.
 */
sibling = \edge, ctx ->
    (ctx
        |> up
        |> (child, edge));

/* Editing
 ******************************************************************************/
/**
 * Get the focus.
 */
getNode = getFocus;

/**
 * Replace focus with `node`.
 */
setNode = \node, ctx -> setFocus(ctx, node);

/**
 * Modify focus with function `f` and replace it with result.
 */
modifyNode = \f, ctx ->
    setNode(
        f(getNode(ctx)),
        ctx);

/**
 * Removes the focus. Moves to either the first right sibiling, or the
 * left right sibiling or the parent.
 * 
 * Returns null if the focus has no parent.
 */
removeNode = \ctx ->
    (isLast(ctx) ?
        (isFirst(ctx) ?
            (!hasParent(ctx) ? null : constructParent(ctx)) :
            setRights(left(ctx), NIL)) :
        modifyLefts(
            right(ctx),
            (skip, 2)));

/**
 * Insert a sibling to the left of the focus. Stays in the current location.
 */
insertLeft = \name, node, ctx ->
    modifyLefts(ctx, \ls ->
        stream.append(
            ls,
            stream.cons(Pair(name, node), NIL)));

/**
 * Insert a sibling to the right of the focus. Stays in the current location.
 */
insertRight = \edge, node, ctx ->
    modifyRights(ctx, \rs ->
        stream.cons(
            Pair(edge, node),
            rs));

/**
 * Insert a child at the left for the focus. Stays in the current location.
 */
insertChild = \edge, node, ctx ->
    (ctx
        |> down
        |> (insertLeft, edge, node)
        |> up);

/**
 * Insert a child at the right for the focus. Stays in current location.
 */
appendChild = \edge, node, ctx ->
    (hasChildren(ctx) ?
        (ctx
            |> down
            |> rightmost
            |> (insertRight, edge, node)
            |> up) :
        setNode(
            construct(ctx, getFocus(ctx), stream.cons(Pair(edge, node), NIL)),
            ctx));

/* Zipper
 ******************************************************************************/
/**
 * Create a generic zipper.
 * 
 * @param edges Function taking a node and returning an array of edges
 *     the children of this node.
 * @param getChild Function taking a node and key and returning the child.
 * @param constructNode Function taking a node, ordered list of edges, and map of
 *    edges to children and returns a new node from these children.
 * @param focus Starting point and current context for the zipper.
 */
zipper = \edges, getChild, constructNode, focus ->
    new Context(
        Loc.setFocus(Loc.empty, focus),
        edges,
        getChild,
        constructNode);

/**
 * Create a zipper for a tree with child edges stored on the node.
 */
treeZipper = let
    getChild = \obj, key -> obj[key]
in
    \edges, construct, root ->
        zipper(
            edges,
            getChild,
            construct,
            root);
}