/**
 * @fileOverview Zipper structures and operations.
 */
package (
// State
    path,
    lefts,
    rights,

// Node Queries
    getChildren,
    getChild,
    getParent,
    
// Node Predicates
    hasChildren,
    hasParent,
    isRoot,
    isChild,
    isLeaf,
    isFirst,
    isLast,
    
// Basic Movement
    up,
    down,
    left,
    right,

// Compound Movement
    root,
    leftmost,
    rightmost,
    leftLeaf,
    rightLeaf,
    
    nextUpDfs,
    nextDfs,
    prevDfs,
    
// Editing
    getNode,
    setNode,
    modifyNode,
    removeNode,
    insertLeft,
    insertRight,
    insertChild,
    appendChild,

// Zipper Creation
    zipper,
    treeZipper)
with
    import 'nu/stream' stream{append, cons, first, rest, isEmpty, 'end': NIL, foldl},
    import 'nu/select' {skip}
in {

var flip = \f -> \x, y -> f(y, x);

var reverse = (foldl,
    flip(cons),
    NIL);

// Context
////////////////////////////////////////
var Context = function(loc, getChildren, getChild, constructNode) {
    this.loc = loc;
    this.getChildren = getChildren;
    this.getChild = getChild;
    this.constructNode = constructNode;
};

Context.setLoc = \ctx, loc ->
    new Context(
        loc,
        ctx.getChildren,
        ctx.getChild,
        ctx.constructNode);

// Loc
////////////////////////////////////////
var Loc = function(focus, parent, path, left, right) {
    this.focus = focus;
    this.parent = parent;
    this.path = path;
    this.left = left;
    this.right = right;
};

Loc.empty = new Loc(null, null, NIL, NIL, NIL);

Loc.setFocus = \loc, focus ->
    new Loc(
        focus,
        loc.parent,
        loc.path,
        loc.left,
        loc.right);

Loc.setLeft = \loc, left ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        left,
        loc.right);

Loc.setRight = \loc, right ->
    new Loc(
        loc.focus,
        loc.parent,
        loc.path,
        loc.left,
        right);

/* Internal operations
 ******************************************************************************/
var getLoc = \ctx -> ctx.loc;

var setLoc = \ctx, loc -> Context.setLoc(ctx, loc);

var modifyLoc = \ctx, f -> setLoc(ctx, f(getLoc(ctx)));

var setFocus = \ctx, f -> modifyLoc(ctx, \loc -> Loc.setFocus(loc, f));

var setLefts = \ctx, ls -> modifyLoc(ctx, \loc -> Loc.setLeft(loc, ls));

var setRights = \ctx, rs -> modifyLoc(ctx, \loc -> Loc.setRight(loc, rs));

var modifyLefts = \ctx, f -> setLefts(ctx, f(ctx.loc.left));

var modifyRights = \ctx, f -> setRights(ctx, f(ctx.loc.right));

var getFocus = \ctx -> getLoc(ctx).focus;

/* Context Operations
 ******************************************************************************/
var pushPath = \x, ctx -> cons(x, path(ctx));

var popPath = path \> rest;

var setPath = \x, ctx -> cons(x, rest(path(ctx)));

/* Reconstruction
 ******************************************************************************/
var construct = \ctx, parent, children ->
    ctx.constructNode(
        parent,
        children);

var constructParent = \ctx -> 
    construct(ctx,
        getParent(ctx).focus,
        append(
            reverse(lefts(ctx)),
            cons(getFocus(ctx), NIL),
            rights(ctx)));

/* Context Query
 ******************************************************************************/
/**
 * Get ordered path to the focus.
 * 
 * Paths are in reverse order, with the first item being the edge leading
 * from the focus's parent to the focus.
 * 
 * @return Stream of path, may be infinite.
 */
path = \ctx -> getLoc(ctx).path;

/**
 * Get ordered list of the focus's left siblings.
 * 
 * The left path is kept in reverse order, with the first element being the
 * element next to the focus.
 * 
 * @return Stream, may be infinite.
 */
lefts = \ctx -> getLoc(ctx).left;

/**
 * Get ordered list of the focus's right siblings.
 * 
 * @return Stream, may be infinite.
 */
rights = \ctx -> getLoc(ctx).right;

/* Node Queries 
 ******************************************************************************/
/**
 * Get order list of focus's child edges.
 */
getChildren = \ctx -> let
    children  = ctx.getChildren(getFocus(ctx))
in
    (Array.isArray(children) ?
        stream.from(children) :
        children);

/**
 * Get the parent of the focus.
 */
getParent = \ctx -> getLoc(ctx).parent;

/* Node Predicates
 ******************************************************************************/
/**
 * Does the focus have any children?
 */
hasChildren = getChildren \> (!) <\ isEmpty;

/**
 * Does the focus have a parent?
 */
hasParent = getParent \> (!==, null);

/**
 * Is the focus a root node?
 */
isRoot = (!) <\ hasParent;

/**
 * Is the focus a child node?
 */
isChild = hasParent;

/**
 * Is the focus a leaf node?
 */
isLeaf = (!) <\ hasChildren;

/**
 * Is the focus the leftmost of its siblings?
 */
isFirst = lefts \> isEmpty;

/**
 * Is the focus the rightmost of its siblings?
 */
isLast = rights \> isEmpty;

/* Basic Movement
 ******************************************************************************/
/**
 * Move to the parent of the focus.
 * 
 * Returns null if the focus has no parent.
 */
up = \ctx ->
    (!hasParent(ctx) ? null :
        setLoc(ctx,
            Loc.setFocus(
                getParent(ctx),
                constructParent(ctx))));

/**
 * Move downwards to the leftmost child of the focus.
 * 
 * Returns null if the focus has no children.
 * 
 * This is an order dependent operation.
 */
down = \ctx ->
    (!hasChildren(ctx) ? null :
        let
            children = getChildren(ctx),
            child = first(children)
        in
            setLoc(ctx,
                new Loc(
                    child,
                    getLoc(ctx),
                    pushPath(child, ctx),
                    NIL,
                    rest(children))));

/**
 * Move left to the next left sibling of the focus.
 * 
 * Returns null if there are no left siblings.
 * 
 * This is an order dependent operation.
 */
left = \ctx -> let
    ls = lefts(ctx)
in
    (isEmpty(ls) ? null :
        let l = first(ls) in
            setLoc(ctx,
                new Loc(
                    l,
                    getParent(ctx),
                    setPath(l, ctx),
                    rest(lefts(ctx)),
                    cons(
                        getFocus(ctx),
                        rights(ctx)))));

/**
 * Move right to the next right sibling of the focus.
 * 
 * Returns null if there are no right siblings.
 * 
 * This is an order dependent operation.
 */
right = \ctx -> let
    rs = rights(ctx)
in
    (isEmpty(rs) ? null :
        let r = first(rs) in
            setLoc(ctx,
                new Loc(
                    r,
                    getParent(ctx),
                    setPath(r, ctx),
                    cons(
                        getFocus(ctx),
                        lefts(ctx)),
                    rest(rights(ctx)))));

/* Compound Movement
 ******************************************************************************/
/**
 * Move to the root of the tree.
 * 
 * Returns the focus if it is the root.
 */
root = \ctx ->
    let parent = up(ctx) in
        (parent ? root(parent) : ctx);

/**
 * Move to the leftmost sibling of the focus.
 * 
 * Returns the focus if it has no left siblings.
 */
leftmost = \ctx ->
    let l = left(ctx) in
        (l ? leftmost(l) : ctx);

/**
 * Move to the rightmost sibling of the focus.
 * 
 * Returns the focus if it has no right siblings.
 */
rightmost = \ctx ->
    let r = right(ctx) in
        (r ? rightmost(r) : ctx);

/**
 * Move to the leftmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
leftLeaf = \ctx ->
    let child = down(ctx) in
        (child ? leftLeaf(child) : ctx);

/**
 * Move to the rightmost leaf of the focus.
 * 
 * Returns the focus if it has no children.
 */
rightLeaf = \ctx ->
    let child = down(ctx) in
        (child ?
            rightLeaf(rightmost(child)) :
            ctx);

/**
 * Move to the next node in a DFS excluding the focus's children.
 * 
 * Returns null if at root.
 */
nextUpDfs = \ctx ->
    let parent = up(ctx) in 
        (parent ?
            (right(parent) || nextUpDfs(parent)) :
            parent);

/**
 * Move to the next node in a DFS traversal.
 */
nextDfs = \ctx ->
    (down(ctx) || right(ctx) || nextUpDfs(ctx));

/**
 * Move to the previous node in a DFS traversal.
 */
prevDfs = \ctx ->
    let l = left(ctx) in
        (l ?
            rightLeaf(l) :
            up(ctx));

/* Editing
 ******************************************************************************/
/**
 * Get the focus.
 */
getNode = getFocus;

/**
 * Replace focus with `node`.
 */
setNode = \node, ctx -> setFocus(ctx, node);

/**
 * Modify focus with function `f` and replace it with result.
 */
modifyNode = \f, ctx ->
    setNode(
        f(getNode(ctx)),
        ctx);

/**
 * Removes the focus. Moves to either the first right sibiling, or the
 * left right sibiling or the parent.
 * 
 * Returns null if the focus has no parent.
 */
removeNode = \ctx ->
    (isLast(ctx) ?
        (isFirst(ctx) ?
            (!hasParent(ctx) ? null : constructParent(ctx)) :
            setRights(left(ctx), NIL)) :
        modifyLefts(
            right(ctx),
            (skip, 2)));

/**
 * Insert a sibling to the left of the focus. Stays in the current location.
 */
insertLeft = \node, ctx ->
    modifyLefts(ctx, \ls ->
        cons(
            node,
            ls));

/**
 * Insert a sibling to the right of the focus. Stays in the current location.
 */
insertRight = \node, ctx ->
    modifyRights(ctx, \rs ->
        cons(
            node,
            rs));

/**
 * Insert a child at the left for the focus. Stays in the current location.
 */
insertChild = \node, ctx ->
    (ctx
        |> down
        |> (insertLeft, node)
        |> up);

/**
 * Insert a child at the right for the focus. Stays in current location.
 */
appendChild = \node, ctx ->
    (hasChildren(ctx) ?
        (ctx
            |> down
            |> rightmost
            |> (insertRight, node)
            |> up) :
        setNode(
            construct(ctx, getFocus(ctx), cons(node, NIL)),
            ctx));

/* Zipper
 ******************************************************************************/
/**
 * Create a generic zipper.
 * 
 * @param edges Function taking a node and returning an array of edges
 *     the children of this node.
 * @param getChild Function taking a node and key and returning the child.
 * @param constructNode Function taking a node, ordered list of edges, and map of
 *    edges to children and returns a new node from these children.
 * @param focus Starting point and current context for the zipper.
 */
zipper = \edges, getChild, constructNode, focus ->
    new Context(
        Loc.setFocus(Loc.empty, focus),
        edges,
        getChild,
        constructNode);

}