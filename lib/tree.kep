/**
 * @fileOverview Zipper operations for generic labeled nary, trees.
 * 
 * Most of these operations redefine the core zipper operations for labeled trees.
 * The core operations can still be used, but since the core has no concept of
 * edges, these will return Pairs of `edge` and `value` instead of node values
 * directly.
 */
package (
// Location Query
    edgePath
    nodePath
    
// Focus Queries
    node
    edge
    childNode
    parentNode
    childNodes

// Labeled Movement
    child
    nthChild
    sibling
    
// Basic Editing
    setNode
    modifyNode
    
    setEdge
    modifyEdge
    
// Labeled Editing
    insertLeft
    insertRight
    insertChild
    appendChild

// Zipper Creation
    treeZipper)
with
    import './zipper' zipper#{
        right
        left
        up
        down},
    import 'nu-stream::stream' stream#{
        cons
        first
        foldl
        indexed
        isStream
        map
        toArray},
    import 'nu-stream::select' {skip}
in {

var toStream = \s ->
    (isStream(s) ? s : stream.from(s));

var indexOf = \e, s ->
    foldl(
        \p [i c] ->
            (p >= 0 ? p : (c === e ? i : p)),
        -1,
        indexed <| s);

var Pair = \key value -> ({'key': key, 'value': value});

var key = \{key} -> key;
var value = \{value} -> value;

/* Queries
 ******************************************************************************/
/**
 * Get the value of the focus.
 * 
 * @param ctx
 */
node = zipper.extract \> value;

/**
 * Get the value of the edge leading to the focus.
 * 
 * @param ctx
 */
edge = zipper.extract \> key;

/**
 * Get list edges leading to the focus.
 * 
 * @return Stream.
 */
edgePath = zipper.path \> (map, key);

/**
 * Get a list of nodes leading to, and including, the focus.
 * 
 * @return Stream.
 */
nodePath = zipper.path \> (map, value);

/**
 * Get the value of the parent of the focus.
 */
parentNode = zipper.parent \> value;

/**
 * Get the values of all children of the focus.
 */
childNodes = zipper.children \> (map, value);

/**
 * Get the value of a child.
 */
childNode = \edge ctx ->
    let c = child(edge, ctx) in
        (c ? node(c) : null);

/* Labeled Movement
 ******************************************************************************/
/**
 * Move to the nth child of focus.
 * 
 * Returns null if no such child exists.
 *
 * @param index Index of child to move to.
 */
nthChild = let
    goRight = \ctx, count ->
        (count <= 0 ?
            ctx :
            goRight(right(ctx), count - 1))
in
    \index, ctx ->
        let child = down(ctx) in
            (child ?
                goRight(child, index) :
                null);

/**
 * Move to the child from `edge` of focus.
 * 
 * Returns null if no such child exists.
 * 
 * @param edge Label of edge to move on.
 */
child = \edge, ctx ->
    (!ctx ? null :
        let
            children = zipper.children(ctx),
            index = indexOf(edge, map(key, children))
        in
            (index === -1 ? null : nthChild(index, ctx)));

/**
 * Move to the sibling with `edge` leading from the focus's parent.
 * 
 * Returns null if no such sibling exists. Returns the focus if `edge`
 * leads to it.
 * 
 * @param edge Label of edge to move on.
 */
sibling = \edge ctx ->
    (ctx
        |> up
        |> (child, edge));

/* Basic Editing
 * 
 * Use `neith/zipper` operations to modify edge, value pair of nodes.
 ******************************************************************************/
/**
 * Set the current focus.
 * 
 * Keeps current edge.
 * 
 * @param node New focus.
 * @param ctx
 */
setNode = \node, ctx ->
    zipper.replace(
        Pair(key(zipper.extract(ctx)), node),
        ctx);

/**
 * Modify the current focus
 * 
 * Keeps current edge
 * 
 * @param f Function mapping current focus to replacement.
 * @param ctx
 */
modifyNode = \f, ctx ->
    setNode(
        f(node(ctx)),
        ctx);

/**
 * Set the current focus.
 * 
 * Keeps current edge.
 * 
 * @param edge New edge leading to focus.
 * @param ctx
 */
setEdge = \edge, ctx ->
    zipper.replace(
        Pair(key(zipper.extract(ctx)), node),
        ctx);

/**
 * Modify the current focus
 * 
 * Keeps current edge
 * 
 * @param f Function mapping current focus to replacement.
 * @param ctx
 */
modifyEdge = \f, ctx ->
    setNode(
        f(edge(ctx)),
        ctx);
    
/* Labled Editing
 ******************************************************************************/
/**
 * Insert a sibling to the left of the focus. Stays in the current location.
 *
 * Does not perform any checks to make sure edge is unique.
 */
insertLeft = \edge, node, ctx ->
    zipper.insertLeft(
        Pair(edge, node),
        ctx);

/**
 * Insert a sibling to the right of the focus. Stays in the current location.
 * 
 * Does not perform any checks to make sure edge is unique.
 */
insertRight = \edge, node, ctx ->
    zipper.insertRight(
        Pair(edge, node),
        ctx);

/**
 * Insert a child at the left for the focus. Stays in the current location.
 * 
 * Does not perform any checks to make sure edge is unique.
 */
insertChild = \edge, node, ctx ->
    zipper.insertChild(
        Pair(edge, node),
        ctx);

/**
 * Insert a child at the right for the focus. Stays in current location.
 * 
 * Does not perform any checks to make sure edge is unique.
 */
appendChild = \edge, node, ctx ->
    zipper.appendChild(
        Pair(edge, node),
        ctx);

/* Zipper
 ******************************************************************************/
/**
 * Create a generic tree zipper.
 * 
 * @param edges Function taking a node and returning a stream or array of edges
 *     for the children of this node.
 * @param getChild Function taking a node and edge and returning the child.
 * @param constructNode Function taking a node, list of edge values pairs,
 *  ordered list of edges, and map of edges to children and returns a new
 *  node from these children.
 * @param focus Starting point and current context for the zipper.
 */
treeZipper = let
    reducer = \p {key value} -> {
        p[key] = value;
        return p;
    }
in
    \edges getChild constructNode focus -> let
        children = \{value} ->
            map(
                \x -> Pair(x, getChild(value, x)),
                toStream(edges(value))),
            
        _constructNode = \parent, children ->
            Pair(
                key(parent),
                constructNode(
                    value(parent),
                    children,
                    toArray(map(key, children)),
                    foldl(reducer, {}, children)))
    in
        zipper.zipper(
            children,
            _constructNode,
            Pair(null, focus));

}